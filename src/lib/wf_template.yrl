Nonterminals
wf_page
wf_body
wf_body_item
%wf_section_open
%wf_section_close
%wf_tags
wf_tag
%wf_element wf_elements
%wf_element_attrs wf_element_attr
%wf_start_tag wf_close_tag
%wf_start_element wf_end_element
%wf_var wf_call
%wf_atom_or_string
%wf_atom_string_integer
wf_string
wf_chars
wf_single_char
%wf_tag_attrs
%wf_tag_attr
%wf_attr_name
%wf_hyphen_attr_name
.

Terminals
string
%atom string integer '<' '>' '/' '=' '-'
wf_char wf_whitespace
wf_close_tag wf_open_tag
%'#' '[' ']'
.

Expect 0.

Rootsymbol wf_page.

%%Nonassoc 100 '='.
%%Right 200 '-'.
%Nonassoc 50 '<' '/'.
%Nonassoc 50 '>'.
%Unary 0 wf_tag.
%Unary 0 wf_body.


Left 100 wf_single_char.
Left 50 wf_chars.
Left 200 wf_whitespace.

wf_page -> wf_body
           : lists:flatten(['$1']).

%wf_page -> wf_section_start wf_body wf_section_end
%           : ['$2'].
%wf_page -> wf_section_start wf_section_end
%           : {nil, ?anno('$1')}.

wf_body -> wf_body_item
           : ['$1'].
wf_body -> wf_body_item wf_body
           : ['$1' | '$2'].

wf_body_item -> string
                : ['$1'].
wf_body_item -> wf_tag
                : ['$1'].
wf_body_item -> wf_string
                : ['$1'].

wf_string -> wf_chars
             : assemble_string('$1').

wf_chars -> wf_single_char wf_chars
            : ['$1' | '$2'].
%wf_chars -> wf_chars wf_chars
%            : '$1' ++ '$1'.
wf_chars -> wf_single_char
            : ['$1'].

wf_single_char -> wf_char
                  : '$1'.
wf_single_char -> wf_whitespace
                  : '$1'.

%wf_tags -> wf_tag
%           : ['$1'].
%           %: {cons, ?anno('$1'), '$1', {nil, ?anno('$1')}}.
%wf_tags -> wf_tag wf_tags
%           : ['$1' | '$2'].
%           %: {cons, ?anno('$1'), '$1', '$2'}.
%wf_tags -> wf_element wf_tags
%           : {cons, ?anno('$1'), '$1', '$2'}.
%wf_tags -> wf_element
%           : {cons, ?anno('$1'), '$1', {nil, ?anno('$1')}}.
%

wf_tag -> wf_open_tag wf_body wf_close_tag
          : match_tag('$1', '$2', '$3').
wf_tag -> wf_open_tag wf_close_tag
          : match_tag('$1', [], '$2').
%wf_tag -> wf_open_tag wf_close_tag
%          : match_tag('$1', [], '$2').


%wf_open_tag -> '<' atom '>'
%                : {open_tag, ?anno('$1'), '$2', []}.
%%wf_open_tag -> '<' atom wf_tag_attrs '>'
%%                : {open_tag, ?anno('$1'), '$2', '$3'}.
%
%wf_close_tag -> '<' '/' atom '>'
%              : {close_tag, ?anno('$1'), '$3'}.
%%wf_close_tag -> '<' '/' '>'
%%              : {universal_close_tag, ?anno('$1')}.
%
%
%wf_tag_attrs -> wf_tag_attr wf_tag_attrs
%                : {cons, ?anno('$1'), '$1', '$2'}.
%wf_tag_attrs -> wf_tag_attr
%                : {cons, ?anno('$1'), '$1', {nil, ?anno('$1')}}.
%
%wf_tag_attr -> wf_attr_name '=' wf_atom_string_integer
%               : build_tag_attr('$1', '$2').
%wf_tag_attr -> wf_attr_name
%               : build_tag_attr('$1', {atom, ?anno('$1'), true}).
%
%wf_atom_or_string -> atom
%                     : '$1'.
%wf_atom_or_string -> string
%                     : '$1'.
%
%wf_atom_string_integer -> wf_atom_or_string
%                          : '$1'.
%wf_atom_string_integer -> integer
%                          : '$1'.
%
%wf_attr_name -> wf_hyphen_attr_name
%                : '$1'.
%
%wf_hyphen_attr_name -> wf_atom_string_integer '-' wf_hyphen_attr_name
%                       : build_attr_name('$1', '$2').
%wf_hyphen_attr_name -> wf_atom_string_integer
%                       : '$1'.


%wf_element -> '<' '#' atom '>' wf_tags '<' '/' '#' atom '>'
%wf_element -> '<' '#' atom '>' wf_tags '<' '/' '#' atom '>'

%wf_var -> '$' var 

Header
"%% Generated by wf_template.yrl"
.

Erlang code.

-export([match_tag/3,
        test_string/1,
        test1/0,
        test2/0,
        test3/0,
        redo/0
        ]).

-define(anno(Tup), element(2, Tup)).

match_tag({wf_open_tag, OpenAnno, {TagName1, Attrs0}}, Body, {wf_close_tag, CloseAnno, TagName2}) ->
    Attrs = process_attrs(Attrs0),
    io:format("Attrs in match_tag: ~p~n",[Attrs]),
    OpenTag0 = lists:flatten(["<",wf:to_list(TagName1)," ",Attrs,">"]),
    CloseTag0 = lists:flatten(["</",wf:to_list(TagName2),">"]),
    OpenTag = stringify(OpenTag0, OpenAnno),
    CloseTag = stringify(CloseTag0, CloseAnno),

    Term = [
        OpenTag,
        Body,
        CloseTag
    ],
  %  Term = {cons, OpenAnno, OpenTag,
  %      {cons, OpenAnno, Body,
  %          {cons, CloseAnno, CloseTag,
  %              {nil, CloseAnno}}}},
  %  io:format("Term: ~p~n",[Term]),
  %  io:format("Returning Term~n"),
    Term.


assemble_string([]) ->
    [];
assemble_string(Chars) ->
    {_, Anno, _} = hd(Chars),
    ActualChars = [get_val(Char) || Char <- Chars],
    {string, Anno, ActualChars}.

process_attrs([]) ->
    [];
process_attrs(Attrs0) ->
    Attrs = [Attr || {wf_attr, _, Attr} <- Attrs0],
    string:join(Attrs, " ").
  
test_string(Str) ->
    {ok, Tokens, _} = wf_template_scan:string(Str, 1),
    %io:format("Tokens: ~p~n",[Tokens]),
    wf_template:parse(Tokens).

get_val({_, _Anno, V}) ->
    V.

stringify(Str, Anno) ->
    {string, Anno, Str}.

test1() ->
    Str = "<a></a>",
    test_string(Str).

test2() ->
    Str = "<a>
    <b>
    </b>
    </a>",
    test_string(Str).

test3() ->
    Str = wf_template_scan:html(),
    test_string(Str).

redo() ->
    yecc:file(?FILE, [verbose, {parserfile, "/tmp/wf_template.erl"}]).
