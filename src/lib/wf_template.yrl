%% vim: ft=erlang
Nonterminals
wf_page
wf_body
wf_body_item
%wf_section_open
%wf_section_close
%wf_tags
wf_tag
%wf_element wf_elements
%wf_element_attrs wf_element_attr
%wf_start_tag wf_close_tag
%wf_start_element wf_end_element
%wf_var wf_call
%wf_atom_or_string
%wf_atom_string_integer
wf_string
wf_chars
wf_whites
wf_close
%wf_tag_attrs
%wf_tag_attr
%wf_attr_name
%wf_hyphen_attr_name
.

Terminals
string
%atom string integer '<' '>' '/' '=' '-'
wf_char wf_whitespace
wf_close_tag wf_universal_close_tag wf_open_tag
wf_self_close_tag
wf_comment
wf_var
%'#' '[' ']'
.

Expect 0.

Rootsymbol wf_page.

%%Nonassoc 100 '='.
%%Right 200 '-'.
%Nonassoc 50 '<' '/'.
%Nonassoc 50 '>'.
%Unary 0 wf_tag.
%Unary 0 wf_body.


%Left 100 wf_single_char.
Right 150 wf_char wf_whitespace.

wf_page -> wf_body
           : ["[", lists:flatten(['$1']), "]"].

%wf_page -> wf_section_start wf_body wf_section_end
%           : ['$2'].
%wf_page -> wf_section_start wf_section_end
%           : {nil, ?anno('$1')}.

wf_body -> wf_body_item
           : ['$1'].
wf_body -> wf_body_item wf_body
           : ['$1', ",", '$2'].

wf_body_item -> wf_var
                : make_var('$1').
wf_body_item -> string
                : stringify(get_val('$1')).
wf_body_item -> wf_tag
                : '$1'.
wf_body_item -> wf_string
                : stringify('$1').

wf_string -> wf_comment
             : get_val('$1').
wf_string -> wf_chars
             : assemble_string('$1').
wf_string -> wf_whites
             : assemble_string('$1').

wf_chars -> wf_char wf_chars
            : ['$1' | '$2'].
wf_chars -> wf_char
            : ['$1'].

wf_whites -> wf_whitespace
             : ['$1'].
wf_whites -> wf_whitespace wf_whites
             : ['$1' | '$2'].


%wf_tags -> wf_tag
%           : ['$1'].
%           %: {cons, ?anno('$1'), '$1', {nil, ?anno('$1')}}.
%wf_tags -> wf_tag wf_tags
%           : ['$1' | '$2'].
%           %: {cons, ?anno('$1'), '$1', '$2'}.
%wf_tags -> wf_element wf_tags
%           : {cons, ?anno('$1'), '$1', '$2'}.
%wf_tags -> wf_element
%           : {cons, ?anno('$1'), '$1', {nil, ?anno('$1')}}.
%

wf_tag -> wf_open_tag wf_whites wf_body wf_whites wf_close
          : match_tag('$1', '$3', '$5').
wf_tag -> wf_open_tag wf_whites wf_body wf_close
          : match_tag('$1', '$3', '$4').
wf_tag -> wf_open_tag wf_body wf_whites wf_close
          : match_tag('$1', '$2', '$4').
wf_tag -> wf_open_tag wf_body wf_close
          : match_tag('$1', '$2', '$3').
wf_tag -> wf_open_tag wf_whites wf_close
          : match_tag('$1', [], '$3').
wf_tag -> wf_open_tag wf_close
          : match_tag('$1', [], '$2').
wf_tag -> wf_self_close_tag
          : match_tag('$1', [], self).
%wf_tag -> wf_open_tag wf_close
%          : match_tag('$1', [], '$2').

wf_close -> wf_close_tag
            : '$1'.
wf_close -> wf_universal_close_tag
            : '$1'.

%wf_open_tag -> '<' atom '>'
%                : {open_tag, ?anno('$1'), '$2', []}.
%%wf_open_tag -> '<' atom wf_tag_attrs '>'
%%                : {open_tag, ?anno('$1'), '$2', '$3'}.
%
%wf_close -> '<' '/' atom '>'
%              : {close_tag, ?anno('$1'), '$3'}.
%%wf_close -> '<' '/' '>'
%%              : {universal_close_tag, ?anno('$1')}.
%
%
%wf_tag_attrs -> wf_tag_attr wf_tag_attrs
%                : {cons, ?anno('$1'), '$1', '$2'}.
%wf_tag_attrs -> wf_tag_attr
%                : {cons, ?anno('$1'), '$1', {nil, ?anno('$1')}}.
%
%wf_tag_attr -> wf_attr_name '=' wf_atom_string_integer
%               : build_tag_attr('$1', '$2').
%wf_tag_attr -> wf_attr_name
%               : build_tag_attr('$1', {atom, ?anno('$1'), true}).
%
%wf_atom_or_string -> atom
%                     : '$1'.
%wf_atom_or_string -> string
%                     : '$1'.
%
%wf_atom_string_integer -> wf_atom_or_string
%                          : '$1'.
%wf_atom_string_integer -> integer
%                          : '$1'.
%
%wf_attr_name -> wf_hyphen_attr_name
%                : '$1'.
%
%wf_hyphen_attr_name -> wf_atom_string_integer '-' wf_hyphen_attr_name
%                       : build_attr_name('$1', '$2').
%wf_hyphen_attr_name -> wf_atom_string_integer
%                       : '$1'.


%wf_element -> '<' '#' atom '>' wf_tags '<' '/' '#' atom '>'
%wf_element -> '<' '#' atom '>' wf_tags '<' '/' '#' atom '>'

Header
"%% Generated by wf_template.yrl"
.

Erlang code.

-include("wf.hrl").

-export([match_tag/3,
        string/1,
        string/2,
        test1/0,
        test2/0,
        test3/0,
        test4/0,
        redo/0
        ]).

-define(anno(Tup), element(2, Tup)).

match_tag({_OpenTagType, OpenAnno, {TagName1, Attrs0}}, Body, CloseTagRaw) ->
    {CloseAnno, TagName2} = case CloseTagRaw of
        self ->
            {OpenAnno, TagName1};
        {wf_close_tag, CA, TN2} ->
            {CA, TN2};
        {wf_universal_close_tag, CA} ->
            {CA, TagName1}
    end,
    Attrs1 = maybe_add_body(Attrs0, Body),
    Attrs = process_attrs(TagName1, Attrs1),
    io:format("Attrs in match_tag: ~p~n",[Attrs]),
    OpenTag0 = lists:flatten(["#", wf:to_list(TagName1),"{",Attrs]),
    CloseTag0 = "}",
    OpenTag = OpenTag0,
    CloseTag = CloseTag0,
%    OpenTag = stringify(OpenTag0, OpenAnno),
%    CloseTag = stringify(CloseTag0, CloseAnno),

    Term = [
        OpenTag,
        CloseTag
    ],
  %  Term = {cons, OpenAnno, OpenTag,
  %      {cons, OpenAnno, Body,
  %          {cons, CloseAnno, CloseTag,
  %              {nil, CloseAnno}}}},
  %  io:format("Term: ~p~n",[Term]),
  %  io:format("Returning Term~n"),
    Term.

maybe_add_body(Attrs, Body) when ?WF_BLANK(Body) ->
    Attrs;
maybe_add_body(Attrs, Body) ->
    io:format("Adding Body: ~p~n",[lists:flatten([Body])]),
    Attrs ++ [{body, Body}].

assemble_string([]) ->
    [];
assemble_string(Chars) ->
    {_, _Anno, _} = hd(Chars),
    ActualChars = [get_val(Char) || Char <- Chars],
    lists:flatten(ActualChars).

process_attrs(_ElementName, []) ->
    [];
process_attrs(_ElementName, Attrs0) ->
    Attrs = [process_attr(Attr) || Attr <- Attrs0],
    wf:join(Attrs, ",").
  
process_attr({wf_attr, Anno, {Key, Val0}}) ->
    Val = process_attr_val(Val0, Anno),
    [wf:f("'~s'=", [Key]), Val];
process_attr({body, Body}) ->
    ["body=[",Body,"]"].

-define(VAR_RE, "\\@([A-Z_][A-Za-z0-9_]*)").
-define(FRONT_RE, "^" ?VAR_RE).
-define(BACK_RE, ?VAR_RE "$").
-define(WHOLE_RE, "^" ?VAR_RE "$").

-define(REPLACE_OPTS, [{return,list}, unicode, global]).


process_attr_val(Val, Anno) ->
    case re:run(Val, ?VAR_RE, [{capture, none}, unicode]) of
        match ->
            Variants = [
                {?WHOLE_RE, [whole]},
                {?FRONT_RE ".*" ?BACK_RE, [front, back, others, list]},
                {?FRONT_RE, [front, others, add_quotes_end, list]},
                {?BACK_RE "$", [back, others, add_quotes_front, list]},
                {?VAR_RE, [others, add_quotes_front, add_quotes_end, list]}
            ],
            find_and_replace_attr_regexes(Val, Variants);
        nomatch ->
            ["\"",Val,"\""]
    end.
    %% Try different variations:
    %% No Var at all
    %% Var at beginning
    %% Var at end
    %% Var somewhere else
    %Val2 = re:replace(Val, ?VAR_RE, "\", \\1, \"", [{return,list}, unicode, global]),
    %Val3 = ["[\"", Val2, "\"]"],
    %Val3.

find_and_replace_attr_regexes(Val, [{RE, Orientations} | Rest]) ->
    case re:run(Val, RE, [{capture, none}, unicode]) of
        match -> replace_attr_regexes(Val, Orientations);
        nomatch -> find_and_replace_attr_regexes(Val, Rest)
    end.

replace_attr_regexes(Val, Orientations) ->
    lists:foldl(fun(Orientation, ValAcc) ->
        replace_attr_regex(Orientation, ValAcc)
    end, Val, Orientations).

replace_attr_regex(whole, Val) ->
    tl(Val);
replace_attr_regex(front, Val) ->
    re:replace(Val, ?FRONT_RE, "\\1, \"", ?REPLACE_OPTS);
replace_attr_regex(back, Val) ->
    re:replace(Val, ?BACK_RE, "\", \\1", ?REPLACE_OPTS);
replace_attr_regex(others, Val) ->
    re:replace(Val, ?VAR_RE, "\", \\1, \"", ?REPLACE_OPTS);
replace_attr_regex(add_quotes_end, Val) ->
    [Val, "\""];
replace_attr_regex(add_quotes_front, Val) ->
    ["\"", Val];
replace_attr_regex(list, Val) ->
    ["[",Val,"]"].
    

string(Str) ->
    string(Str, 1).

string(Str, Anno) -> 
    file:write_file("tmp/source_code.ntml", Str),
    {ok, Tokens, _} = wf_template_scan:string(Str, Anno),
    {ok, Code} = parse(Tokens),
    io:format("Produced Erlang Code:~n~s~n",[Code]),
    file:write_file("/tmp/temp_code.erl", Code),
    Code.

get_val({_, _Anno, V}) ->
    V.

stringify(Str) ->
    wf:f("\"~s\"", [Str]).
    
    %{string, Anno, Str}.

make_var(Var) ->
    wf:f("~s", [get_val(Var)]).

test1() ->
    Str = "<a></a>",
    string(Str).

test2() ->
    Str = "<a>
    <b>
    </b>
    </a>",
    string(Str).

test3() ->
    Str = wf_template_scan:html(),
    string(Str).

test4() ->
    Body = "
        <#link url=@Prot@Url>@LinkText</#>
        <#panel id=@Wrapperid class=\"@MainClass div-@SecClass\" attr2=something_else>
            <#span class=\"span-@Class2 @Type-badge\">
            </#span>
            <#literal text=@SomeOtherBodyStuff></#>
            <button type=@Type>Click me</button>
            <#table class=\"@TableClass\"></#table>
            <#hr />
            <#span class=swell-@Badge>@not_a_variable</#span>
        </#panel>
    ",
    string(Body).

redo() ->
    yecc:file(?FILE, [verbose, {parserfile, "/tmp/wf_template.erl"}]).
